<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>enc28j60 library: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">enc28j60 library
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">platform agnostic enc28j60 driver with asynchronous IO support and fully compliant with errata</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">enc28j60 library Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is ENC28J60 driver practically platform agnostic, yet targetting mainly baremetal systems. Supports asynchronous writting and reading from <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a>'s internal buffer (fails back to synchronous transfers if the platform does not support asynchronous SPI IO), and is compliant with errata sheet for all versions. Comes with supplied examples and Doxygen documentation. Licensed under MIT license. To learn how to correctly use this library to comply with the errata sheet, see below.</p>
<p><a href="https://dalibor-drgon.github.io/enc28j60/">Documentation</a></p>
<p><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/39662e.pdf">Datasheet</a></p>
<p><a href="http://ww1.microchip.com/downloads/en/DeviceDoc/80349c.pdf">Errata sheet</a></p>
<h1>How to correctly use this library</h1>
<p>When working with <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a>, keep in mind following tips in order for your code to comply with errata sheet:</p>
<ul>
<li>Make sure speed of your SPI is at least 8 MHz, or</li>
<li>use the same 25 MHz oscillator and generate spi clock of 25/2, 25/3, 25/4 ... MHz (errata #1; for B1 and B4 only)</li>
<li>When using <code><a class="el" href="enc28j60_8c.html#a6e4405d4eb4eaadcbacbcd0aa3fb5336" title="Claims space for RX buffer. ">enc28j60_init_rxbuffer()</a></code>, make sure that the RX buffer starts at <code>0000h</code> (errata #5)</li>
<li>Use <code><a class="el" href="enc28j60_8c.html#aeb18851eb58e4d3ba572e5d6953b7015" title="Reads the number of received frames waiting to be processed in the buffer memory (reds the EPKTCNT re...">enc28j60_readrxframescount()</a></code> instead of checking for <code>PKTIF</code> flag (errata #6)</li>
<li>Once the transmission finishes, make sure to call <code><a class="el" href="enc28j60_8c.html#a1bc15c88a531442f5540833889695fae" title="Should be called when transmission finishes in order to avoid bug described in errata #12...">enc28j60_aftertx()</a></code>, <code><a class="el" href="enc28j60_8c.html#aeb10b9cdc6f777752f4d6d3ece8f87aa" title="Reads the seven-byte-long status vector written after TXed frame. ">enc28j60_readtxstatus()</a></code> and <code><a class="el" href="enc28j60_8c.html#ae54a62cb401e5f96858a1fc8659ed7bb" title="Checks for late collision and returns true if late collision happened and remaining_tries is not zero...">enc28j60_shouldretransmit()</a></code> with additional code to retransmit the frame in case of late collision (errata #12, #14, #15; also note that <code>LATECOL</code> flag is unreliable, this is why it's important to call <code><a class="el" href="enc28j60_8c.html#aeb10b9cdc6f777752f4d6d3ece8f87aa" title="Reads the seven-byte-long status vector written after TXed frame. ">enc28j60_readtxstatus()</a></code> and check for late collision there using <code>txstatus.status &amp; ENC28J60_TXSTATUS_LATE_COLLISION</code> - which is done inside <code><a class="el" href="enc28j60_8c.html#ae54a62cb401e5f96858a1fc8659ed7bb" title="Checks for late collision and returns true if late collision happened and remaining_tries is not zero...">enc28j60_shouldretransmit()</a></code>): <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> remaining_retries = 16;</div><div class="line"><a class="code" href="structenc28j60__txstatus.html">enc28j60_txstatus</a> status;</div><div class="line"><span class="keywordflow">do</span> {</div><div class="line">    <a class="code" href="enc28j60_8c.html#a55f173acfe955c3b032a65897cc42dbc">enc28j60_cleartxflags</a>(&amp;eth1);</div><div class="line">    <a class="code" href="enc28j60_8c.html#aa8bdeba76f6551e39dbc8db9a64270de">enc28j60_transmitframe</a>(&amp;eth1);</div><div class="line">    <a class="code" href="enc28j60_8c.html#a681e4911f2fa1590bd49bbd32d4f39c0">enc28j60_jointx</a>(&amp;eth1); <span class="comment">// or wait for interrupt</span></div><div class="line">    <a class="code" href="enc28j60_8c.html#a1bc15c88a531442f5540833889695fae">enc28j60_aftertx</a>(&amp;eth1);</div><div class="line">    <a class="code" href="enc28j60_8c.html#aeb10b9cdc6f777752f4d6d3ece8f87aa">enc28j60_readtxstatus</a>(&amp;eth1, tx_start, tx_length, &amp;status);</div><div class="line">    <a class="code" href="enc28j60_8c.html#adfb5003097e80ebddd77dd2045d6a3a9">enc28j60_decrementretries</a>(&amp;remaining_retries);</div><div class="line">} <span class="keywordflow">while</span>(<a class="code" href="enc28j60_8c.html#ae54a62cb401e5f96858a1fc8659ed7bb">enc28j60_shouldretransmit</a>(&amp;status, remaining_retries));</div></div><!-- fragment --></li>
<li>When sending frames, do CRC calculation in software, as doing this by <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a> will abort currently received packet. (errata #18)</li>
<li>When using pattern match filters, note that extra packets not fitting the filter may be received. (errata #18)</li>
<li>Note that <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a> does not support auto negotiation. That is, with most equipment, it can communicate in only half-duplex unless both ends are manually configured to work in full-duplex (Section 9.0 of datasheet)</li>
</ul>
<h1>Errata</h1>
<table class="doxtable">
<tr>
<th>Module </th><th>Feature </th><th># </th><th>Summary </th><th align="center">B1 </th><th align="center">B4 </th><th align="center">B5 </th><th align="center">B7 </th><th>Implemented in/by  </th></tr>
<tr>
<td>MAC Interface </td><td>- </td><td>1. </td><td>MAC registers unreliable with slow asynchronous SPI clock </td><td align="center">X </td><td align="center">X </td><td align="center"></td><td align="center"></td><td><em>user</em> by setting correct SPI speed </td></tr>
<tr>
<td>Reset </td><td>- </td><td>2. </td><td>CLKRDY set early </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#a0358972c6ffc8a0e18a12e8212115493" title="Sends soft-reset and waits until the enc28j60 is operational again. ">enc28j60_softreset()</a></code> </td></tr>
<tr>
<td>Core </td><td>Operating Specifications </td><td>3. </td><td>Industrial (-40°C to +85°C) temperature range unsupported </td><td align="center">X </td><td align="center">X </td><td align="center"></td><td align="center"></td><td>- </td></tr>
<tr>
<td>Oscillator </td><td>CLKOUT pin </td><td>4. </td><td>CLKOUT unavailable in Power Save mode </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td>- </td></tr>
<tr>
<td>Memory </td><td>Ethernet Buffer </td><td>5. </td><td>Receive buffer must start at 0000h </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> when using <code><a class="el" href="enc28j60_8c.html#a6e4405d4eb4eaadcbacbcd0aa3fb5336" title="Claims space for RX buffer. ">enc28j60_init_rxbuffer()</a></code> </td></tr>
<tr>
<td>Interrupts </td><td>- </td><td>6. </td><td>Receive Packet Pending Interrupt Flag (PKTIF) unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> by using <code><a class="el" href="enc28j60_8c.html#aeb18851eb58e4d3ba572e5d6953b7015" title="Reads the number of received frames waiting to be processed in the buffer memory (reds the EPKTCNT re...">enc28j60_readrxframescount()</a></code> instead of checking for <code>PKTIF</code> </td></tr>
<tr>
<td>PHY </td><td>- </td><td>7. </td><td>TPIN+/- automatic polarity detection and correction unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> by avoiding incorrect RX polarity </td></tr>
<tr>
<td>PHY </td><td>- </td><td>8. </td><td>RBIAS resistor value differs between silicon revisions </td><td align="center">X </td><td align="center">X </td><td align="center"></td><td align="center"></td><td><em>user</em> when designing board </td></tr>
<tr>
<td>PHY </td><td>- </td><td>9. </td><td>Internal loopback in half-duplex unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#afdcc475d0eb776627691ae7ea4801ed2" title="Initializes the enc28j60. ">enc28j60_init()</a></code> </td></tr>
<tr>
<td>PHY </td><td>- </td><td>10. </td><td>Internal loopback in full-duplex unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> </td></tr>
<tr>
<td>PHY LEDs </td><td>- </td><td>11. </td><td>Combined Collision and Duplex Status mode unavailable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> </td></tr>
<tr>
<td>Transmit logic </td><td>- </td><td>12. </td><td>Transmit abort may stall transmit logic </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#a1bc15c88a531442f5540833889695fae" title="Should be called when transmission finishes in order to avoid bug described in errata #12...">enc28j60_aftertx()</a></code> </td></tr>
<tr>
<td>PHY </td><td>- </td><td>13. </td><td>Received link pulses potentially cause collisions </td><td align="center"></td><td align="center"></td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#ae54a62cb401e5f96858a1fc8659ed7bb" title="Checks for late collision and returns true if late collision happened and remaining_tries is not zero...">enc28j60_shouldretransmit()</a></code> </td></tr>
<tr>
<td>Memory </td><td>Ethernet Buffer </td><td>14. </td><td>Even values in ERXRDPT may corrupt receive buffer </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#a702e728c2042eef92799db9e7dd8aca2" title="Writes the ERXRDPTL:ERXRDPTH registers-pointer with appropriate value to free up space in the buffer...">enc28j60_advancerxreadpointer()</a></code> or <code><a class="el" href="enc28j60_8c.html#a85fa097203908966343b81b0367f3541" title="Writes the ERXRDPTL:ERXRDPTH registers-pointer with appropriate value to free up space in the buffer ...">enc28j60_finishreadframe()</a></code> </td></tr>
<tr>
<td>Transmit logic </td><td>- </td><td>15. </td><td>LATECOL Status bit unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#aeb10b9cdc6f777752f4d6d3ece8f87aa" title="Reads the seven-byte-long status vector written after TXed frame. ">enc28j60_readtxstatus()</a></code> </td></tr>
<tr>
<td>PHY LEDs </td><td>- </td><td>16. </td><td>LED auto-polarity detection unreliable </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> </td></tr>
<tr>
<td>DMA </td><td>- </td><td>17. </td><td>DMA checksum calculations will abort receive packets </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> by doing checksum in software </td></tr>
<tr>
<td>Receive Filter </td><td>- </td><td>18. </td><td>Pattern match filter allows reception of extra packets </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><em>user</em> by discarding unwanted packets </td></tr>
<tr>
<td>SPI </td><td>- </td><td>19. </td><td>Reset command unavailable in Power Save mode </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td align="center">X </td><td><code><a class="el" href="enc28j60_8c.html#a0358972c6ffc8a0e18a12e8212115493" title="Sends soft-reset and waits until the enc28j60 is operational again. ">enc28j60_softreset()</a></code> </td></tr>
</table>
<h1>Example usage</h1>
<p>First copy <code><a class="el" href="enc28j60-struct_8example_8h.html" title="Part of enc28j60 driver. ">enc28j60-struct.example.h</a></code> into <code>enc28j60-struct.h</code> and make changes into the code, structures and macros if you wish. You have to choose whenever your system supports advanced spi driver (that is a driver that can transceive to/from two different buffers while keeping <code>SS</code> low all the time). In this guide, we assume that you have advanced driver, but you can find code examples even for the basic driver in <code>/examples/*_nonadv.c</code>.</p>
<p>After customizing the <code>enc28j60-struct.h</code>, implement the functions defined there (<code>enc28j60_spi_transfer()</code> if you don't have advanced SPI driver, <code><a class="el" href="enc28j60-struct_8example_8h.html#a749c657bd134d9ab85fec329d8db9241" title="This function performs (using DMA or blocking I/O) parallely transmision from &#39;tx1&#39; buffer and recept...">enc28j60_spi_advanced_transfer()</a></code> otherwise; <code><a class="el" href="enc28j60-struct_8example_8h.html#ac73e336dd2240227a91551fba06a3e86" title="This function should wait until SPI operation in progress (if any) finishes and then return...">enc28j60_spi_transfer_join()</a></code>, <code><a class="el" href="enc28j60-struct_8example_8h.html#ac212dfc7710731f61dd57d874948db9c" title="This function is called before callback when non-zero error code is received from enc28j60_spi_transf...">enc28j60_spi_error_handler()</a></code>, <code><a class="el" href="enc28j60-struct_8example_8h.html#a0750e72252c1bb897813393bc8f988e7" title="Wait until given number of ticks passes. ">enc28j60_delay()</a></code> and <code><a class="el" href="enc28j60-struct_8example_8h.html#af1f60395fdc701b37931c81b09de5500" title="Get current number of ticks. ">enc28j60_getticks()</a></code>).</p>
<h2>Initialization</h2>
<p>Choose whenever to use full duplex (if available - otherwise half-duplex will be used even if <code>is_full_duplex</code> is true) and whenever to discard frames with invalid CRC and finally chose MAC address. Reset the device and initialize it with chosen parameters.</p>
<div class="fragment"><div class="line"><a class="code" href="structenc28j60.html">enc28j60</a> eth0;</div><div class="line"><span class="comment">/* Reset and initialize enc28j60 */</span></div><div class="line"><a class="code" href="structenc28j60__init__struct.html">enc28j60_init_struct</a> init_struct = {</div><div class="line">    .<a class="code" href="structenc28j60__init__struct.html#a667d17d1ef567fad2819d76cf90c69c5">is_full_duplex</a> = <span class="keyword">true</span>,</div><div class="line">    .discard_crc_errors = <span class="keyword">true</span></div><div class="line">};</div><div class="line"><span class="keywordtype">char</span> mac[] = { 0x00, 0x00, 0x00, 0x01, 0x02, 0x03};</div><div class="line">memcpy(init_struct.<a class="code" href="structenc28j60__init__struct.html#a910db83aa075cf9257ccfac4a43da861">mac_address</a>, mac, 6);</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;Initializing\n&quot;</span>);</div><div class="line"><a class="code" href="enc28j60_8c.html#a0358972c6ffc8a0e18a12e8212115493">enc28j60_softreset</a>(&amp;eth0);</div><div class="line"><a class="code" href="enc28j60_8c.html#afdcc475d0eb776627691ae7ea4801ed2">enc28j60_init</a>(&amp;eth0, &amp;init_struct);</div><div class="line">...</div></div><!-- fragment --><p>Note that you can modify the <code>struct <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a></code> and add for example a pointer to the SPI device you wish to use. Then the first lines will look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="structenc28j60.html">enc28j60</a> eth0;</div><div class="line">eth0.spi_pointer = &amp;spi1_dma;</div><div class="line"><span class="comment">/* Reset and initialize enc28j60 */</span></div><div class="line">... </div></div><!-- fragment --><h2>Reception</h2>
<p>It's possible to setup interrupts to handle reception of frames, however to keep things simple we start with simple blocking architecture. First you can choose, whenever you wish to accept broadcast and multicast packets, set where RX buffer starts and ends, and then finally enable the receiver and wait for frames.</p>
<div class="fragment"><div class="line">...</div><div class="line">enc28j60_enablebroadcast(&amp;eth0, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="enc28j60_8c.html#a299019a5dbe3c1af99ae9fd64d7101e4">enc28j60_enablemulticast</a>(&amp;eth0, <span class="keyword">true</span>);</div><div class="line"><span class="comment">// use whole memory as receive buffer</span></div><div class="line"><a class="code" href="enc28j60_8c.html#a6e4405d4eb4eaadcbacbcd0aa3fb5336">enc28j60_init_rxbuffer</a>(&amp;eth0, 0, <a class="code" href="enc28j60_8h.html#afdc607c793b19ae1f5a117bede3f38e2">ENC28J60_MEMORY_SIZE</a>-1);</div><div class="line"></div><div class="line"><span class="comment">/* Enable receiver and start receiving packets */</span></div><div class="line">printf(<span class="stringliteral">&quot;Receiving...\n&quot;</span>);</div><div class="line"><a class="code" href="enc28j60_8c.html#ab255f915f0f58474ff5deadd0a66c3f9">enc28j60_enablerx</a>(&amp;eth0);</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> frame[<a class="code" href="enc28j60_8h.html#acaadc03d704f0a2f7bc237dbb1ab451f">ENC28J60_MAX_FRAMELEN_ETH</a> + <span class="keyword">sizeof</span>(<a class="code" href="enc28j60_8h.html#a40450e60958fb45dc7eef32f9cd082b4">enc28j60_header</a>)];</div><div class="line"></div><div class="line"><span class="keywordflow">while</span>(1) {</div><div class="line">    uint8_t cnt;</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">        <span class="comment">// Loop until we have received any frame</span></div><div class="line">        <a class="code" href="enc28j60_8c.html#aeb18851eb58e4d3ba572e5d6953b7015">enc28j60_readrxframescount</a>(&amp;eth0, &amp;cnt);</div><div class="line">    } <span class="keywordflow">while</span>(cnt == 0);</div><div class="line"></div><div class="line">    <span class="comment">// or call the following code in interrupt (EIR.PKTIF - it is reliable as source of interrupt, but unreliable when you read it from EIR register)</span></div><div class="line">    <a class="code" href="enc28j60_8c.html#a2a01d3d124160c7c198cd54dc0360930">enc28j60_readframe</a>(&amp;eth0, frame, <span class="keyword">sizeof</span>(frame), NULL);</div><div class="line">    <a class="code" href="enc28j60_8c.html#a85fa097203908966343b81b0367f3541">enc28j60_finishreadframe</a>(&amp;eth0); </div><div class="line">    <span class="keywordtype">unsigned</span> length = eth0.<a class="code" href="structenc28j60.html#a069171f78d32ca168f2abd63dd5836de">length</a>;</div><div class="line"></div><div class="line">    do_whatever_you_want_with_frame(frame, length);</div><div class="line">}</div></div><!-- fragment --><p>or, if you want to prototype faster, you can just use built-in function <code><a class="el" href="enc28j60_8c.html#a590aa0182af9980bc40e9225aa6f7cd0" title="Wait until there is frame available in the buffer, read it into local memory, do cleanup and return...">enc28j60_receiveframeblocking()</a></code> which either waits at most given number of ticks, or waits infinitely if <code>0</code> is supplied as <code>timeout</code> argument until a frame is received (if you don't want this function to block, simply check the number of received frames yourself before calling this function):</p>
<div class="fragment"><div class="line">...</div><div class="line">while(1) {</div><div class="line">    <a class="code" href="enc28j60_8c.html#a590aa0182af9980bc40e9225aa6f7cd0">enc28j60_receiveframeblocking</a>(&amp;eth0, frame, <span class="keyword">sizeof</span>(frame), 0);</div><div class="line">    <span class="keywordtype">unsigned</span> length = eth0.<a class="code" href="structenc28j60.html#a069171f78d32ca168f2abd63dd5836de">length</a>;</div><div class="line"></div><div class="line">    do_whatever_you_want_with_frame(frame, length);</div><div class="line">}</div></div><!-- fragment --><p>But note that this function blocks - if you don't want it to block, you can simply check the amount of received frames, and if at least one was received, the call to <code>enc28j60_receciveframeblocking()</code> won't wait, but immediately start reading that frame from <a class="el" href="structenc28j60.html" title="Structure holding important informations about enc28j60 and about the latest transmission performed...">enc28j60</a>'s memory.</p>
<h2>Transmission</h2>
<p>The transmission is simple as well, and the code below can be divided into two pieces, one part of which gets executed somewhere in the application, while the other part might get executed from interrupt.</p>
<div class="fragment"><div class="line">...</div><div class="line">char tx_frame[] = {...}; <span class="comment">// ethernet frame with valid CRC at the end</span></div><div class="line">uint16_t start_ptr = <a class="code" href="enc28j60_8h.html#afdc607c793b19ae1f5a117bede3f38e2">ENC28J60_MEMORY_SIZE</a> - 0x600;</div><div class="line"><a class="code" href="enc28j60_8c.html#ae353d94056b89e52b7c4f385bf4b047b">enc28j60_writeframe</a>(&amp;eth0, 0,</div><div class="line">    start_ptr, tx_frame, <span class="keyword">sizeof</span>(tx_frame), NULL</div><div class="line">);</div><div class="line"><a class="code" href="enc28j60_8c.html#ab3d57ae04a06bd5129eccdb4916244c6">enc28j60_init_txbuffer</a>(&amp;eth0, start_ptr, <span class="keyword">sizeof</span>(tx_frame));</div><div class="line"></div><div class="line">printf(<span class="stringliteral">&quot;Transmitting...\t&quot;</span>);</div><div class="line"><span class="keywordtype">unsigned</span> remaining_retries = 16;</div><div class="line"><a class="code" href="structenc28j60__txstatus.html">enc28j60_txstatus</a> status;</div><div class="line"><span class="keywordflow">do</span> {</div><div class="line">    <a class="code" href="enc28j60_8c.html#a55f173acfe955c3b032a65897cc42dbc">enc28j60_cleartxflags</a>(&amp;eth0);</div><div class="line">    <a class="code" href="enc28j60_8c.html#aa8bdeba76f6551e39dbc8db9a64270de">enc28j60_transmitframe</a>(&amp;eth0);</div><div class="line">    <a class="code" href="enc28j60_8c.html#a681e4911f2fa1590bd49bbd32d4f39c0">enc28j60_jointx</a>(&amp;eth0); </div><div class="line">    <span class="comment">// enc28j60_jointx() or run the following code from interrupt on EIR.TXIF or EIR.TXERIF flag</span></div><div class="line">    <a class="code" href="enc28j60_8c.html#a1bc15c88a531442f5540833889695fae">enc28j60_aftertx</a>(&amp;eth0);</div><div class="line">    <a class="code" href="enc28j60_8c.html#aeb10b9cdc6f777752f4d6d3ece8f87aa">enc28j60_readtxstatus</a>(&amp;eth0, start_ptr, <span class="keyword">sizeof</span>(tx_frame), &amp;status);</div><div class="line">    <a class="code" href="enc28j60_8c.html#adfb5003097e80ebddd77dd2045d6a3a9">enc28j60_decrementretries</a>(&amp;remaining_retries);</div><div class="line">} <span class="keywordflow">while</span>(<a class="code" href="enc28j60_8c.html#ae54a62cb401e5f96858a1fc8659ed7bb">enc28j60_shouldretransmit</a>(&amp;status, remaining_retries));</div><div class="line">printf(<span class="stringliteral">&quot;done\n&quot;</span>);</div></div><!-- fragment --><p>This code may seem non-trivial, but without the extra effort it would not be compliant with errata #12, #13, #15, and the transceiver could freeze. The last few lines can be however simplified by using built-in function <code><a class="el" href="enc28j60_8c.html#ab64074e15e39508131200154bf959a1f" title="Writes an ethernet frame of given length into enc28j60&#39;s memory starting at given pointer and transmi...">enc28j60_transmitframeblocking()</a></code>:</p>
<div class="fragment"><div class="line">printf(<span class="stringliteral">&quot;Transmitting...\t&quot;</span>);</div><div class="line"><a class="code" href="enc28j60_8c.html#ab64074e15e39508131200154bf959a1f">enc28j60_transmitframeblocking</a>(&amp;eth0, start_ptr, <span class="keyword">sizeof</span>(tx_frame));</div><div class="line">printf(<span class="stringliteral">&quot;done\n&quot;</span>);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
